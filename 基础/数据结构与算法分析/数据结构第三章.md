## 抽象数据类型

抽象数据类型(Abstract Data Type 简称ADT)是指一个数学模型以及定义在此数学模型上的一组操作。

## 表 ADT

+ 基本概念

我们将处理形如A1, A2, A3, ..., AN的一般的表.这个表的大小是N. 我们将称大小为0的表为空表(empty list)。对于除空表外的任何表, 我们说Ai+1后继Ai(或继Ai之后),并称Ai-1前驱Ai(i>1).表中的第一个元素是A1, 而最后一个元素是AN。我们将不定义A1的前驱元,也不定义AN的后继元. 元素Ai在表中的位置(position)为i。

表ADT上进行操作的集合一般有：  
1. printList: 打印表;
2. makeEmpty: 清空表;
3. find: 返回关键字首次出现的位置;
4. insert: 从表的某个位置插入元素;
5. delete: 从表的某个位置删除元素;
6. findKth:返回某个位置上的元素。

+ 表的简单数组实现

分析：  
1. 在部分语言中，数组大小是固定的，需要对表的大小的最大值进行估计，通常需要估计得大一些，从而浪费大量的空间，这是严重的局限
2. printList、find以线性时间执行
3. findKth花费常数时间
4. insert、delete需要将整个数组前移或后移一个位置，因此这两种操作的最坏情况为O(n)

因为插入和删除的运行时间是如此的慢以及在部门语言中表的大小必须事先已知，所以简单数组一般不用来实现表的这种结构

+ 链表

链表由一系列不必在内存中相连的结构组成。每一个结构均含有表元素和指向包含该元素后继元的结构的指针。我们称之为next指针。最后一个单元的next指针指向NULL。

分析：
1. 表可以不连续存储，避免了插入和删除的线性开销，无需考虑表的初始化大小
2. printList、find以线性时间执行
3. findKth操作不如数组实现效率高；findKth(L, i)花费O(i)时间以显性方式穿越链表完成。因为调用findKth常常是以(按i)排序的方式进行，例如findKth(L, 2),findKth(L, 3),findKth(L, 4)以及findKth(L, 6)可通过对表的一次扫描同时实现
4. insert需要使用一次malloc(动态内存分配)调用从系统得到一个新单元并在此后执行两次指针调整；delete可以通过修改一个指针来实现

还有几处地方可能会出现问题。首先，并不存在从所给定义出发在表的前面插入元素的真正显性的方法；第二，从表的前面实行删除是一种特殊情况，因为它改变了表的起始端，编程中的疏忽会造成表的丢失；第三个问题涉及一般的删除。虽然指针的移动很简单，但是删除算法要求我们记住被删除的单元。事实上，稍作一些简单的变化就能够解决所有这三个问题。留出一个标志节点，有时称为表头，有时称为哑节点。

