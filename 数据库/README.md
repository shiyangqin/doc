# 数据库

+ [mysql](mysql)
+ [PostgreSQL](PostgreSQL)
+ [Redis](Redis)
+ [mongo](mongo)
+ [es](es)

## 事务
  
+ [事务的四大特性](#事务的四大特性)
+ [隔离级别](#隔离级别)

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

#### 事务的四大特性

数据库事务（transanction）正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。

+ 原子性(Atomicity)

    整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

+ 一致性(Correspondence)

    事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

+ 隔离性(Isolation)

    一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

+ 持久性(Durability)

    一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

#### 隔离级别

如果不考虑事务的隔离性，会发生的几种问题：

+ 脏读

    事务未commit,另一个事务读取数据

+ 不可重复读

    一个事务对同一行数据重复读取两次，但是却得到了不同的结果.

+ 虚读(幻读)

    两个事务都同时更新一行数据，一个事务对数据的更新把另一个事务对数据的更新覆盖了

隔离级别从低到高，性能从高到低：

+ 读未提交——Read Uncommitted

    1. 所有事务都可以看到其他未提交事务的执行结果
    2. 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少
    3. 该级别引发的问题是:脏读、不可重复读、幻读

+ 读已提交——Read Committed

    1. 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）
    2. 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变
    3. 这种隔离级别出现的问题是:不可重复读、幻读

+ 可重复读——Repeatable Read

    1. 这是MySQL的默认事务隔离级别
    2. 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行
    3. 该级别引发的问题是:幻读
    4. InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题

+ 可串行化——Serializable

    1. 这是最高的隔离级别
    2. 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。
    3. 在这个级别，可能导致大量的超时现象和锁竞争
