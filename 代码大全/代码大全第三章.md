### 核对表：需求

+ 针对功能需求

    详细定义系统的全部输入，包括来源、精度、取值范围、出现频率  
    详细定义系统的全部输出，包括来源、精度、取值范围、出现频率、格式  
    详细定义所有输出格式  
    详细定义所有的硬件和软件的外部接口  
    详细定义全部外部通信接口，包括握手协议、纠错协议、通信协议等  
    列出用户想要做的全部事情  
    详细定义了每个任务所用的数据，以及每个任务得到的数据  

    个人思考：  
    对于模块的外部接口，根据最初我自己的想法是根据松散耦合的原则，我们不去处理其他模块的数据，同时其他模块也不需要处理我们的数据，所以对于接口，我的想法是对于我需要的数据，我会提供我需要的数据并按照我自己需要的格式给他一份样本，数据提供方按照我给的样本给我数据就好了，我需要提供的数据，我会按照他们的样本去组装好给他们。但是这里有一个问题，如果数据需求方的格式有变化，提供方的工作量就会增加，而且修改的频率是无法预估的，如果数据需求方频繁的改数据格式，我们就要频繁的去为他们增加很多的工作量。这肯定是非常不友好的。  

    详细定义每个任务所用的数据非常重要，定义数据的时候，需要考虑到数据格式的通用性以及后续可能会出现的需求变更，一个好的数据格式，应该是即使数据发生了变化，但只需对输入数据进行简单修改，不需要去修改已有的代码，只需添加新的数据即可，如果最初定义的数据格式出现较大变化，很可能会有大量的逻辑代码需要修改，这会是一个工作量非常大的变动，对于已投入使用的项目，这种改动的实现更加困难  


+ 针对非功能需求（质量需求）

    是否为全部必要的操作，从用户的视角，详细描述了期望响应的时间？  
    详细描述了其他与计时有关的考虑，例如处理时间、数据传输率、系统吞吐量  
    详细定义了安全级别  
    详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检测与恢复的策略等  
    详细定义了机器内存和剩余磁盘空间的最小值  
    详细定义了系统的可维护性，包括适应特点功能的变更、操作环境的变更、与其他软件的接口的变更能力  
    是否包含对“成功”的定义？“失败”的定义  

    个人思考：  
    对于质量需求，我个人接触的不太多，也就对系统的维护性有点体会，功能的变更如果需要改的大量代码，甚至重写一些功能，那么系统的可维护性真的就很差了

+ 需求的质量

    用用户的语言书写，用户也这么认为吗？  
    每条需求都不与其他需求冲突吗？  
    是否详细定义了相互竞争的特性之间的权衡——例如健壮性和正确性之间的权衡？  
    是否避免在需求中规定设计（方案）？  
    需求是否在详细程度上保持相对一直的水平？有些需求应该更详细地描述吗？有些需求应该更粗略的描述吗？  
    需求是否足够清晰，即使转交给一个独立的小组去构建，他们也能理解吗？开发者也是这么想的吗？  
    每个条款都与待解决的问题及其解决方案有关吗？能从条款上溯到它在问题中对应的根源吗？  
    是否每条需求都是可测试的，是否可能进行独立的测试，以检验满不满足各项需求？  
    是否详细描述了所有可能的对需求的改动，包括各项改动的可能性？  

    个人思考：  
    对于这部分暂时只停留在产品把需求给我，所以我的个人感受就是当一个完全不懂开发的产品将他的需求提完后，你要即使指出里面那些在开发看来非常不合适的地方，甚至在必要的时候，向他简单说明一下开发的方式以及与需求的冲突，然后对需求进行修改，得到一个双方都认可的需求方案。

+ 需求的完备性

    对于开发之前无法获取的信息，是否详细描述了信息不完全的区域？  
    需求的完备度是否能达到这种程度：如果产品满足所有需求，那么它就是可接收的  
    你对全部需求都感到很舒服吗？你是否已经去掉了那些不可能实现的需求————那些只是为了安抚客户和老板的东西？  


### 读书笔记


 架构的质量决定了系统的“概念完整性”。后者继而决定了系统的最终质量。一个经过慎重考虑的构架为“从顶端到底层维护系统的概念完整性”提供了必备的结构和体系，它为程序员提供了指引——其细节程度与程序员的技能和手边的工作相配。它将工作分为几个部分，使多个开发者或多个开发团队可以独立工作。

好的架构使得构建活动变得更容易。糟糕的架构则使架构活动几乎寸步难行。
    
### 架构的典型组成部分

程序组织  
主要的类  
数据设计  
业务规则  
用户界面设计  
资源管理  
安全性  
性能  
可伸缩性  
互用性  
国际化/本地化  
输入/输出  
错误处理  
容错性  
构架的可行性  
过度工程  
关于“买”还是“造”的决策  
关于复用的决策  
变更策略  
构建的总体质量  
    
### 核对表：架构

+ 针对各架构主题

    程序的整体组织结构清晰，包含一个良好的架构全局观  
    明确定义了主要的构造块（包括每个构造快的职责范围及其他构造块的接口）   
    明显涵盖“需求”中列出的所有功能（每个功能对应的构架块不太多也不太少）  
    描述并论证了那些最关键的类  
    描述并论证了数据设计  
    详细定义了数据库的组织结构和内容  
    指出所有了所有关键的业务规则，并描述其对系统的影响  
    描述了用户界面设计的策略  
    将用户界面模块化，使界面的变更不会影响程序其余部分  
    描述并论证了处理I/O的策略  
    估算了稀缺资源（如线程、数据库连接、句柄、网络带宽等）的使用量，是否描述并论证了资源管理的策略  
    描述了架构的安全需求  
    架构为每个类、每个子系统、或每个功能域提出空间与时间预算  
    架构是否关注互操作性  
    描述了国际化/本地化策略  
    提供了一套内聚的错误处理策略  
    规定了容错的方法（如果需要）  
    证实了系统各个部分的技术可行性  
    详细描述了过度工程的方法  
    包含了必要的“买 vs 造”的决策  
    构架描述了如何加工被复用的代码，使之符合其他架构目标
    将架构设计得能够适应很可能出现的变更

+ 架构的总体质量

    架构解决了全部需求  
    有没有哪个部分使“过度架构”或“欠架构”？是否明确宣布了在这方面的预期指标？  
    整个架构在概念上协调一致  
    顶层设计独立于用作实现它的机器和语言  
    说明了所有主要的决策的动机  
    你，作为一个实现该系统的程序员，是否对这个架构感觉良好？ 

### 核对表：前期准备

+ 前期准备

    辨明了自己所从事的软件的类型，并对所用的开发方法做出相应的剪裁  
    充分明确地定义了需求，而且需求很稳定，能开始构建了  
    充分明确地定义了架构，以便开始构建  
    已经指出你的（当前）项目中独有的风险（以避免构建活动面临不必要的风险）

 