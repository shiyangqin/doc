### 变量定义

+ 隐式声明

    关闭隐式声明  
    声明全部的变量  
    遵循某种命名规则  
    检查变量名

+ 变量初始化原则

    在声明变量的时候初始化  
    在靠近变量第一次使用的位置初始化它  
    理想情况下，在靠近第一次使用变量的位置声明和定义该变量  
    在可能的情况下使用final和const  
    特别注意计算器和累加器  
    在类的构造函数里初始化该类的数据成员  
    检查是否需要重新初始化  
    一次性初始化具名常量，用可执行代码来初始化变量  
    使用编辑器设置来自动初始化所有变量  
    利用编辑器的告警信息  检查输入参数的合法性  
    使用内存访问检查工具来检查错误的指针  
    在程序开始时初始化工作内存  

+ 作用域

    使变量引用局部化  
    尽可能缩短变量的“存活”时间  
    减小作用域   

### 核对表：使用数据的一般事项

+ 初始化变量

    每一个子程序都检查其输入参数的正确性了吗？  
    变量声明位置靠近变量第一次使用的位置吗？  
    尽可能地在声明变量的同时初始化变量吗？  
    如果无法同时声明变量和初始化变量，有没有在靠近第一次使用变量的位置声明变量？  
    计数器和累加器经过了适当的初始化吗？如果需要再一次使用，之前重新初始化了吗？  
    适当地重新初始化“需要重复执行地代码里的变量”了吗？  
    代码在通过编译器编译的时候是不是没有警告信息？  
    如果你用的语言允许隐式声明，你为由此引发的问题做好补偿措施了吗？  

+ 使用数据的其他事项

    如果可能，所有变量都被定义为具有最小的作用域吗？  
    各变量的引用点都尽可能集中在一起吗？对同一变量的两次相邻引用，或者变量的整个生命期都这样做了吗？  
    控制结构符合数据类型吗？  
    所有声明的变量都用到了吗？  
    变量都在合适的时间绑定了吗？——也就是说，你有意识地在晚期绑定所带来的灵活性和增加的复杂度之间做出平衡了吗？  
    每个变量都有且仅有一项用途吗？  
    每个变量的含义都很明确且没有隐含含义吗？  
