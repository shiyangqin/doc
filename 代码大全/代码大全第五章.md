### 读书笔记

“险恶的”问题就是一种只有通过解决或部分解决才能被明确的问题（1973）。这个看似矛盾的定义其实就是在暗示说，你必须把这个问题“解决”一遍以便能过明确地定义它，然后再次解决该问题，从而形成一个可行地方案。

个人思考：实际中确实有很多问题确实是这样的，例如迭代就是最好的例子，这一次的设计普遍比上一次的好，这是在设计中不断发现问题解决问题的成果，如果在编码阶段才进行一次次修改，所付出的代价往往是比较大的。

 ### 关键的设计概念

 应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分，这么做的目的是尽量减少在任一时间所要考虑的程序量。通过把整个系统分解为多个子系统来降低问题的复杂度。人们更易于理解许多项简单的问题，而不是一项复杂的信息。

 受着人类固有限制影响的程序员的底线，就是要写出既让自己容易理解，也能让别人容易看懂，而且很少有错误的程序代码。

+  高代价、低效率的设计源于下面三种根源：  
    
    用复杂的方法解决简单的问题  
    用简单但错误的方法解决复杂的问题  
    用不恰当的复杂方法解决复杂的问题  

+ 管理复杂度：  
    
    把任何人在同一时间需要处理的本质复杂度的量降到最少  
    不要让偶然性的复杂度无谓地快速增长  

 + 理想的设计特征：

    最小的复杂度  
    易于维护  
    松散耦合  
    可拓展性  
    可重用性  
    高扇入  
    低扇出  
    可移植性  
    精简性  
    层次性  
    标准技术  
     
+ 设计的层次：

    软件系统  
    分解为子系统和包  
    分解为包中的类  
    分解为类中的数据和子程序  
    子程序内部  

+ 面向对象设计方法：   

    辨识对象及其属性（方法（method）和数据（data））  
    确定可以对各个对象进行的操作  
    确定各个对象能对其他对象进行的操作  
    确定对象的哪些部分对其他对象可见——哪些部分可以是公用（public）的，哪些部分应该是私有（private）的  
    定义每个对象的公开接口  

### 设计构造快：启发式方法

+ 主要的设计中的启发式方式：

    找出现实世界中的对象  
    形成一致的抽象  
    封装实现细节  
    当继承能简化设计时就继承  
    **信息隐藏**  
    找出容易改变的区域  
    **保持松散耦合**  
    **查阅常用的设计模式**  
    
+ 其他的启发式方式：

    高内聚性  
    构造分层结构  
    严格描述类契约  
    分配职责  
    为测试而设计  
    避免失误  
    有意识地选择绑定时间  
    创建中央控制点  
    考虑使用蛮力  
    画一个图  
    保持设计模块化  

### 设计实践  

+ 设计实践的启发式方法  

    迭代  
    分而治之  
    自上而下和自下而上的设计方法  
    建立试验性原型  
    合作设计  
    要做多少设计才够  
    记录你的设计成果  

### 核对表：软件构造中的设计

+ 设计实践

    已经做过多次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择第一次尝试的结果  
    尝试用多种方案来分解系统，以确定最佳方案  
    同时用自下而上和自上而下的方法来解决设计问题  
    为了解决某些特定的问题，对系统中的风险部份或者不熟悉的部分创建过原型、写过数量较少的可抛弃代码  
    设计方案被其他人检查了吗？  
    一直在展开设计，直到实施细节跃然纸上  
    用某种适当的而技术来保留设计成果

+ 设计目标

    设计充分地处理了由系统架构层定义出并推迟确定地事项  
    设计被分为层次  
    对把这一程序分解成为子程序、包、和类地方式感到满意  
    对这个类分解成为子程序地方法感到满意  
    类和类之间地交互关系已设计为最小化  
    类和子程序被设计为能够在其他系统中重用  
    程序已于维护  
    设计精简，设计出来的每一部分都绝对必要  
    设计中采用了标准的技术，避免使用怪异且难以理解的元素  
    整体而言，你的设计有助于最小化偶然性的和本质性的复杂度