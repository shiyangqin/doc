## 核对表：重构的理由

代码重复  
子程序太长  
循环太长或者嵌套太深  
类的内聚性太差  
类的接口的抽象层次不一致  
参数表中参数太多  
类的内部修改往往局限于某个部分  
需要对多个类进行并行修改  
对继承体系的并行修改  
需要对多个case语句进行并行修改  
相关的数据项只是被放在一起，没有组织到类中  
成员函数更多地使用了其他类的功能，而非自身类的  
过于依赖基础数据类型  
一个类不做什么事  
一连串传递流浪数据的子程序  
中间人对象什么也不干  
某个类同其他类关系过于密切  
子程序的命名太差  
数据成员被设置为公用  
派生类仅仅使用了基类的一小部分成员函数  
用注释来掩饰拙劣的代码  
使用了全局变量  
在子程序调用前使用设置代码，调用或使用收尾代码  
程序包含的某些代码似乎在将来某个时候才会被用到

## 核对表：重构总结

### 数据级的重构

用具名常量来代替神秘变量  
用更明确或更具信息量的名字来重命名变量  
将表达式内联化  
用函数来代替表达式  
引入中间变量  
将多用途变量转换为多个单一用途变量  
使用局部变量实现局部用途而不是使用参数  
将基础数据类型转化为类  
将一组类型码转化为类或者枚举类型  
将一组类型码转化为含派生类的类  
将数组转化为对象  
封装集群  
用数据类代替传统记录   

### 语句级的重构

分解布尔表达式  
将复杂的布尔表达式转换为命名精确的布尔函数  
将条件语句中不同部分不中重复代码合并  
使用break或者return而不是循环控制变量  
在嵌套的if-then-else语句中一旦知道结果就立刻退出，而不是仅仅赋一个返回值  
用多态来代替条件语句（尤其是重复的case语句）  
创建并使用空对象代替对空值的检测

### 子程序级的重构

提取子程序  
将子程序代码内联化  
将冗长的子程序转化为类  
用简单的算法代替复杂算法  
增加参数  
减少参数  
将查询操作同修改操作区分开来  
合并功能相似的子程序，并用参数来区分他们  
通过传递不同的参数是子程序体现不同的功能  
传递整个对象而非特定成员  
传递特定成员而非整个对象  
封装向下转型操作

### 类实现的重构

将值对象改为引用对象  
将引用对象改为值对象  
用数据初始化来代替虚函数  
改变成员函数或数据的位置  
将特定代码提出生成派生类  
将相似的代码合并起来放到基类中  

### 类接口的重构

将某成员子程序放到另一个类中  
将一个类转化成二个  
删除某个类  
隐藏委托关系  
去掉中间人  
用委托代替继承  
用继承代替委托  
引入外部子程序  
引入拓展类  
封装暴露在外的成员变量  
对不能修改的成员去掉set()函数  
隐藏在类的外部不会使用的成员函数  
封装不会哦那个到的成员函数  
如果基类和派生类的代码实现相似，将二者合并

### 系统级的重构

为无法控制的数据创建明确的索引源  
将单向类联系改为双向类联系  
将双向类联系改为单向类联系  
使用工厂函数而非简单的构造函数  
用异常代替错误代码，或者反其道而行之

## 核对表：安全的重构

每一改变都是系统改变策略的一部分吗？  
在重构之前，你保存了初始代码了吗？  
你是否保持较小的重构步伐？  
你是否同一时间只处理一项重构？  
在重构时你是否把要做的事情一条一条列了出来？  
你是否设置了一个停车场，把你在重构时所想到的任何东西记下来？  
在每次重构后你会重新测试吗？  
如果所做的修改非常复杂，或者影响到了关键代码，你会重新检查这些修改吗？  
你是否考虑过特定重构的风险，并以此来调整你的重构方法？  
你所做的修改是提升还是降低了程序的内在质量？  
你是否避免了将重构作为先写后改的代名词，或者作为拒绝重写劣质代码的托词？