<!-- TOC -->

- [概述](#概述)
- [事务](#事务)
- [ORM数据库隔离层](#orm数据库隔离层)
- [AOP](#aop)
- [依赖注入](#依赖注入)
- [RESTfulApi](#restfulapi)
- [路由](#路由)
- [模板引擎](#模板引擎)
- [CORS跨域访问](#cors跨域访问)
- [AutoMapper](#automapper)
- [DDD领域驱动设计](#DDD领域驱动设计)

<!-- TOC -->

# 概述

开发web应用基础知识

目录顺序有所调整，与实际内容顺序有所不同

## RESTfulApi

你的API越容易使用，那么就会有越多的人去用它

参考资料：  
https://github.com/aisuhua/restful-api-design-references  
https://www.restapitutorial.com/lessons/restquicktips.html  
https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2
https://blog.csdn.net/a78270528/article/details/78469758

## RESTfulApi是做什么的？

REST(Representational State Transfer表述性状态转移)是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。  

RESTful API就是REST风格的API

## 什么是RESTfulApi？
REST架构风格描述了六种约束。应用于架构的这些约束最初由Roy Fielding在他的博士论文中传达（参见https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm ），并定义了RESTful的基础样式。

+ **统一接口（Uniform Interface）**  
通信链的组件之间通过统一的接口相互通信，以提高交互的可见性。
+ **无状态（Stateless）**  
通信的会话状态（Session State）应该全部由客户端负责维护。
+ **缓存（Cache）**  
响应内容可以在通信链的某处被缓存，以改善网络效率。
+ **客户-服务器（Client-Server）**  
通信只能由客户端单方面发起，表现为请求-响应的形式。
+ **分层系统（Layered System）**  
通过限制组件的行为（即每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。
+ **按需代码（Code-On-Demand，可选）**  
支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。

## RESTfulApi建议

无论是技术上是不是REST（根据前面提到的六个约束条件），这里有一些推荐的REST概念。这六个快速提示将带来更好，更实用的服务。

+ 使用HTTP动词  

    API使用者能够发送GET，POST，PUT和DELETE动词，这极大地增强了给定请求的清晰度。通常，四个主要HTTP谓词使用如下：  

    操作|说明
    -|-
    get|读取特定资源（通过标识符）或资源集合。
    PUT|更新特定资源（通过标识符）或资源集合。如果资源标识符是事先已知的，也可以用于创建特定资源。
    PATCH|只更新服务器上一个资源的一个属性。
    DELETE|通过标识符删除/删除特定资源。
    POST|创建一个新资源。对于不适合其他类别的操作，也是一个包罗万象的动词。
    |不常用的：
    HEAD|获取一个资源的元数据，如数据的哈希值或最后的更新时间。
    OPTIONS|获取客户端能对资源做什么操作的信息。

    注意：一个好的RESTful API只允许第三方调用者使用这四个半HTTP动词进行数据交互，并且在URL段里面不出现任何其他的动词。一般来说，GET请求可以被浏览器缓存（通常也是这样的）。GET请求不得更改任何底层资源数据。可能仍会发生更新数据的测量和跟踪，但URI标识的资源数据不应更改。

+ 提供合理的资源名称  

    拥有合理的资源名称（只是URL路径，例如/ customers / 12345 / orders）可以提高给定请求的清晰度。适当的资源名称为服务请求提供上下文，从而提高API的可理解性。资源通过其URI名称进行分层查看，为消费者提供友好，易于理解的资源层次结构，以便在其应用程序中使用。  

    以下是一些URL路径（资源名称）设计的快速规则：

    + 在您的网址中使用标识符而不是在查询字符串中。使用URL查询字符串参数非常适合过滤，但不适用于资源名称。  
        好： / users / 12345  
        差： / api？type = user＆id = 23  
    + 利用URL的分层特性来暗示结构。
    + 为您的客户而不是您的数据设计。
    + 资源名称应为名词。避免使用动词作为资源名称，以提高清晰度。使用HTTP方法指定请求的谓词部分。  
    + 在URL段中使用复数形式，以使用集合隐喻使您的API URI在所有HTTP方法中保持一致。  
        推荐： / customers / 33245 / orders / 8769 / lineitems / 1  
        不是： / customer / 33245 / order / 8769 / lineitem / 1  
    + 避免在URL中使用集合措辞。例如'customer_list'作为资源。使用复数来表示集合隐喻（例如，customers与customer_list）。
    + 在URL段中使用小写，用下划线（'_'）或连字符（' - '）分隔单词。有些服务器会忽略大小写，所以最好清楚。
    + 保持网址尽可能短，尽可能少的网段。

+ 使用HTTP响应代码指示状态  

    响应状态代码是HTTP规范的一部分。它们中有很多可以解决最常见的情况。本着使RESTful服务包含HTTP规范的精神，我们的Web API应该返回相关的HTTP状态代码。

+ 提供JSON和XML
    除非特殊情况支持xml，

+ 创建细粒度资源

    在开始时，最好创建模仿系统的底层应用程序域或数据库体系结构的API。最终，您将需要使用多个底层资源的聚合服务来减少干扰。但是，稍后从单个资源创建更大的资源比从较大的聚合创建细粒度或单个资源要容易得多。让自己轻松一点，从易于定义的小型资源开始，为这些资源提供CRUD功能。

+ 考虑连接性

    REST的原则之一是连通性 - 通过超媒体链接（搜索HATEOAS）。虽然没有它们，服务仍然有用，但在响应中返回链接时，API会变得更具自我描述性和可发现性。至少，“自我”链接引用会通知客户端如何检索数据。

## HTTP方法

HTTP动词|CRUD|整个集合（例如/客户）|特定项目（例如/ customers / {id}）
-|-|-|-
POST|创建|201（已创建），'位置'标题，其中包含指向/ customers / {id}的链接，其中包含新ID。|404（未找到），409（冲突），如果资源已存在..
GET|读|200（OK），客户列表。使用分页，排序和过滤来导航大列表。|200（OK），单个客户。404（未找到），如果找不到ID或无效。
PUT|更新/更换|405（方法不允许），除非您要更新/替换整个集合中的每个资源。|200（OK）或204（无内容）。404（未找到），如果找不到ID或无效。
PATCH|更新/修改|405（方法不允许），除非您想要修改集合本身。|200（OK）或204（无内容）。404（未找到），如果找不到ID或无效。
DELETE|删除|405（方法不允许），除非你想删除整个集合 - 通常不需要。|200（好的）。404（未找到），如果找不到ID或无效。

+ POST（CREATE）创建资源

+ GET（SELECT）获取资源

+ PUT（UPDATE）更新资源，客户端需要提供新建资源的所有属性

+ PATCH（UPDATE）更新资源的部分属性（很少用，一般用POST代替）

+ DELETE（DELETE）删除资源

## 资源命名
除了适当地使用HTTP动词之外，在创建易于理解，易于利用的Web服务API时，资源命名可以说是最有争议和最重要的概念。当资源命名良好时，API直观且易于使用。做得不好，相同的API可能会感觉到笨拙并且难以使用和理解。以下是为新API创建资源URI时可以使用的一些建议。

从本质上讲，RESTful API最终只是URI的集合，对这些URI的HTTP调用以及资源的一些JSON和/或XML表示，其中许多将包含关系链接。URIs涵盖RESTful可解决性原则。每个资源都有自己的地址或URI-服务器可以提供的每条有趣的信息都作为资源公开。统一接口的约束部分地通过URI和HTTP动词的组合来解决，并且使用它们符合标准和约定。

**在决定系统中的资源时，将它们命名为名词而不是动词或动作**。换句话说，RESTful URI应该引用一个资源而不是引用一个动作。名词具有动词不具有的属性，只是另一个区别因素。  

服务套件中的每个资源都至少有一个URI标识它。当URI有意义并充分描述资源时，它是最好的。URI应遵循可预测的层次结构，以增强可理解性，从而提高可用性：在数据具有结构关系的意义上，它们是一致的，层次结构的可预测性。这不是REST规则或约束，但它增强了API。

RESTful API是为消费者编写的。URI的名称和结构应该向这些消费者传达意义。通常很难知道数据边界应该是什么，但是通过了解您的数据，您最有可能采取刺激措施以及作为代表返回给客户的有意义的东西。为您的客户而不是您的数据设计。

## 幂等
### 什么是幂等

HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

这里需要关注几个重点：

1、幂等不仅仅只是一次（或多次）请求对资源没有副作用（比如查询数据库操作，没有增删改，因此没有对数据库有任何影响）。

2、幂等还包括第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。

3、幂等关注的是以后的多次请求是否对资源产生的副作用，而不关注结果。

4、网络超时等问题，不是幂等的讨论范围。

幂等性是系统服务对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。

### 什么情况下需要幂等

业务开发中，经常会遇到重复提交的情况，无论是由于网络问题无法收到请求结果而重新发起请求，或是前端的操作抖动而造成重复提交情况。 在交易系统，支付系统这种重复提交造成的问题有尤其明显，比如：
+ 用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；
+ 向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。 很显然，声明幂等的服务认为，外部调用者会存在多次调用的情况，为了防止外部多次调用对系统数据状态的发生多次改变，将服务设计成幂等。

# CORS跨域访问
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

参考文档：http://www.ruanyifeng.com/blog/2016/04/cors.html
## 简介
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

## 两种请求

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

    1. 请求方法是以下三种方法之一：
        HEAD
        GET
        POST
    2. HTTP的头信息不超出以下几种字段：
        Accept
        Accept-Language
        Content-Language
        Last-Event-ID
        Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/ plain

凡是不同时满足上面两个条件，就属于非简单请求。

浏览器对这两种请求的处理，是不一样的。

## 简单请求
+ 基本流程

    对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。

    下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。
    ```
    GET /cors HTTP/1.1
    Origin: http://api.bob.com
    Host: api.alice.com
    Accept-Language: en-US
    Connection: keep-alive
    User-Agent: Mozilla/5.0...
    ```

    上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

    如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

    如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。
    ```
    Access-Control-Allow-Origin: http://api.bob.com
    Access-Control-Allow-Credentials: true
    Access-Control-Expose-Headers: FooBar
    Content-Type: text/html; charset=utf-8
    ```

    上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。

    1. Access-Control-Allow-Origin  
        该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。

    2. Access-Control-Allow-Credentials  
        该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。

    3. Access-Control-Expose-Headers  
        该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。

+ withCredentials 属性

    上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。
    ```
    Access-Control-Allow-Credentials: true
    ```
    另一方面，开发者必须在AJAX请求中打开withCredentials属性。
    ```
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    ```
    否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

    但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。
    ```
    xhr.withCredentials = false;
    ```
    需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。

## 非简单请求
+ 预检请求
    非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

    非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

    浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

    下面是一段浏览器的JavaScript脚本。
    ```
    var url = 'http://api.alice.com/cors';
    var xhr = new XMLHttpRequest();
    xhr.open('PUT', url, true);
    xhr.setRequestHeader('X-Custom-Header', 'value');
    xhr.send();
    ```

    上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。

    浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。
    ```
    OPTIONS /cors HTTP/1.1
    Origin: http://api.bob.com
    Access-Control-Request-Method: PUT
    Access-Control-Request-Headers: X-Custom-Header
    Host: api.alice.com
    Accept-Language: en-US
    Connection: keep-alive
    User-Agent: Mozilla/5.0...
    ```
    "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。

    除了Origin字段，"预检"请求的头信息包括两个特殊字段。
    1. Access-Control-Request-Method  
    该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。

    2. Access-Control-Request-Headers  
    该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。

+ 预检请求的回应

    服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。
    ```
    HTTP/1.1 200 OK
    Date: Mon, 01 Dec 2008 01:15:39 GMT
    Server: Apache/2.0.61 (Unix)
    Access-Control-Allow-Origin: http://api.bob.com
    Access-Control-Allow-Methods: GET, POST, PUT
    Access-Control-Allow-Headers: X-Custom-Header
    Content-Type: text/html; charset=utf-8
    Content-Encoding: gzip
    Content-Length: 0
    Keep-Alive: timeout=2, max=100
    Connection: Keep-Alive
    Content-Type: text/plain
    ```
    上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。
    ```
    Access-Control-Allow-Origin: *
    ```
    如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。
    ```
    XMLHttpRequest cannot load http://api.alice.com.
    Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
    ```
    服务器回应的其他CORS相关字段如下。
    ```
    Access-Control-Allow-Methods: GET, POST, PUT
    Access-Control-Allow-Headers: X-Custom-Header
    Access-Control-Allow-Credentials: true
    Access-Control-Max-Age: 1728000
    ```
    1. Access-Control-Allow-Methods  
    该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
    2. Access-Control-Allow-Headers  
    如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
    3. Access-Control-Allow-Credentials  
    该字段与简单请求时的含义相同。
    4. Access-Control-Max-Age  
    该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

+ 浏览器的正常请求和回应

    一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。

    下面是"预检"请求之后，浏览器的正常CORS请求。
    ```
    PUT /cors HTTP/1.1
    Origin: http://api.bob.com
    Host: api.alice.com
    X-Custom-Header: value
    Accept-Language: en-US
    Connection: keep-alive
    User-Agent: Mozilla/5.0...
    ```
    上面头信息的Origin字段是浏览器自动添加的。

    下面是服务器正常的回应。
    ```
    Access-Control-Allow-Origin: http://api.bob.com
    Content-Type: text/html; charset=utf-8
    ```
    上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。

## 与JSONP的比较

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

# 模板引擎

# ORM数据库隔离层
参考文档：http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html?utm_source=tuicool&utm_medium=referral

面向对象编程和关系型数据库，都是目前最流行的技术，但是它们的模型是不一样的。面向对象编程把所有实体看成对象（object），关系型数据库则是采用实体之间的关系（relation）连接数据。对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。

简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是"对象-关系映射"（Object/Relational Mapping） 的缩写。

ORM 把数据库映射成对象。
```
数据库的表（table） --> 类（class）
记录（record，行数据）--> 对象（object）
字段（field）--> 对象的属性（attribute）
```

例如下面是一行sql语句
```
SELECT id, first_name, last_name, phone, birth_date, sex
 FROM persons 
 WHERE id = 10
```
程序直接运行sql：
```
res = db.execSql(sql);
name = res[0]["FIRST_NAME"];
```
改成 ORM 的写法如下:
```
p = Person.get(10);
name = p.first_name;
```

ORM 使用对象，封装了数据库操作，因此可以不碰 SQL 语言。开发者只使用面向对象编程，与数据对象直接交互，不用关心底层数据库。

总结起来，ORM 有下面这些优点:
+ 数据模型都在一个地方定义，更容易更新和维护，也利于重用代码。
+ ORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。
+ 它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。
+ 基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。
+ 你不必编写性能不佳的 SQL。

但是，ORM 也有很突出的缺点:
+ ORM 库不是轻量级工具，需要花很多精力学习和设置。
+ 对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL。
+ ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。

## 命名规定
许多语言都有自己的ORM库，最典型、最规范的实现公认是Ruby语言的 Active Record。Active Record 对于对象和数据库表的映射，有一些命名限制：

+ 一个类对应一张表。类名是单数，且首字母大写；表名是复数，且全部是小写。比如，表books对应类Book。

+ 如果名字是不规则复数，则类名依照英语习惯命名，比如，表mice对应类Mouse，表people对应类Person。

+ 如果名字包含多个单词，那么类名使用首字母全部大写的骆驼拼写法，而表名使用下划线分隔的小写单词。比如，表book_clubs对应类BookClub，表line_items对应类LineItem。

+ 每个表都必须有一个主键字段，通常是叫做id的整数字段。外键字段名约定为单数的表名 + 下划线 + id，比如item_id表示该字段对应items表的id字段。


# AutoMapper
参考文件：https://www.jianshu.com/p/6ef125e873e9
## 什么是AutoMapper？
AutoMapper是一个对象和对象间的映射器。对象与对象的映射是通过转变一种类型的输入对象为一种不同类型的输出对象工作的。让AutoMapper有意思的地方在于它提供了一些将类型A映射到类型B这种无聊的事情的有趣惯例。只要类型B遵守AutoMapper已经建立的惯例，大多数情况下，映射两种类型零配置就可以了。
## 为什么使用AutoMapper?
映射代码是无聊的。测试映射代码更无聊。AutoMapper提供了一些简单配置，还有一些简单的映射测试。真正的问题可能是“为什么使用对象-对象的映射呢”?映射可能发生在一个应用的许多地方，但大多数情况下都发生在层与层之间的边界，比如UI/Domain层之间，或者Service/Domain层之间。关注一层通常和关注另一层发生冲突，因此对象-对象间的映射来隔离模型model，这样就只会影响每一层关注的类型。

# AOP
AOP(Aspect Oriented Programming)，即面向切面编程。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

## AOP术语

+ 切面(Aspect):切面是通知和切点的结合。通知和切点定义了切面的全部内容——它是什么，在何时何处完成其功能。
+ 通知(Advice):通知定义了切面是什么以及何时使用，应该应用在某个方法被调用之前？之后？还是抛出异常时？等等。
+ 连接点(JointPoint):连接点是在应用执行过程中能够插入切面的一个点。
+ 切入点(Pointcut):切点有助于缩小切面所通知的连接点的范围。如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”，切点会匹配通知所要织入的一个或多个连接点，一般常用正则表达式定义所匹配的类和方法名称来指定这些切点。
+ 引入(Introduction):引入允许我们向现有的类添加新方法或属性，从而无需修改这些现有类的情况下，让他们具有新的行为和状态。
+ 织入(Weaving): 织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。

说明：织入是对方法的增强，引入是对类的增强。

## 通知的类型
前置通知: 在一个方法执行之前，执行通知。  
后置通知: 在一个方法执行之后，不考虑其结果，执行通知。  
返回后通知:|在一个方法执行之后，只有在方法成功完成时，才能执行通知。  
抛出异常后通知:在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。  
环绕通知:在方法调用之前和之后，执行通知。

# 路由
参考资料：https://molunerfinn.com/fe-be-router-render/
## 什么是路由？
在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。

访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。

## 从后端路由讲起
在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入www.baidu.com到你看到网页这个过程中经历了什么」其实讲的也是这个道理。

![web3](img/web/web3.png)

在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个404状态码。这也是我们常说的404 NOT FOUND的由来。

## URL与Methods
如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：GET，POST，PUT，DELETE

它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以GET请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：
```js
router.post('/user/:id', addUser)
```
假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：http://xxx.com/user/123 的话是无法访问到的，也会返回一个404。因为后端只配了一个post方法的路由。如果要接受这个请求，那么必须有如下的路由：
```js
router.get('/user/:id', getUser) // 配置get路由
router.post('/user/:id', addUser)
```
## 后端路由与服务端渲染

前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。

如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的服务端渲染。

服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。

node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。

不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。

于是，我们开始进入了前端路由的时代。

## 过渡到前端路由

前端路由——顾名思义，页面跳转的URL规则匹配由前端来控制。而前端路由主要是有两种显示方式：

+ 带有hash的前端路由，优点是兼容性高。缺点是URL带有#号不好看
+ 不带hash的前端路由，优点是URL不带#号，好看。缺点是既需要浏览器支持也需要后端服务器支持

前端路由应用最广泛的例子就是当今的SPA的web项目。不管是Vue、React还是Angular的页面工程，都离不开相应配套的router工具。前端路由带来的最明显的好处就是，地址栏URL的跳转不会白屏了——这也得益于前端渲染带来的好处。

## 前端路由与前端渲染
讲前端路由就不能不说前端渲染。以Vue项目为例。如果你是用官方的vue-cli搭配webpack模板构建的项目，你有没有想过你的浏览器拿到的html是什么样的？是你页面长的那样有button有form的样子么？我想不是的。在生产模式下，你看看构建出来的index.html长什么样：
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vue</title>
</head>
<body>
  <div id="app"></div>
  <script type="text/javascript" src="xxxx.xxx.js"></script>
  <script type="text/javascript" src="yyyy.yyy.js"></script>
  <script type="text/javascript" src="zzzz.zzz.js"></script>
</body>
</html>
```
通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的html。这里面空荡荡的只有一个`<div id="app"></div>`这个入口的div以及下面配套的一系列js文件。所以你看到的页面其实是通过那些js渲染出来的。这也是我们常说的前端渲染。

![web4](img/web/web4.png)

前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对SEO不友好，毕竟搜索引擎的爬虫只能爬到上面那样的html，对浏览器的版本也会有相应的要求。

需要明确的是，只要在浏览器地址栏输入URL再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用router库的api来进行的URL更新是不会去后端服务器请求的。

## Hash模式
hash模式利用的是浏览器不会对#号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：http://localhost/#/user/1 和 http://localhost/ 其实到服务端都是去请求 http://localhost 这个页面的内容。

而前端的router库通过捕捉#号后面的参数、地址，来告诉前端库（比如Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过router的api进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回http://localhost对应的html，剩下具体是哪个页面，就由前端路由去判断便可。

## History模式

不带#号的路由，也就是我们通常能见到的URL形式。router库要实现这个功能一般都是通过HTML5提供的history这个api。比如history.pushState()可以向浏览器地址栏push一个URL，而这个URL是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的URL。不过需要注意的是，这个api对于IE9及其以下版本浏览器是不支持的，IE10开始支持，所以对于浏览器版本是有要求的。vue-router会检测浏览器版本，当无法启用history模式的时候会自动降级为hash模式。

上面说了，你在页面里的跳转，通常是通过router的api去进行的跳转，router的api调用的通常是history.pushState()这个api，所以跟后端没什么关系。但是一旦你从浏览器地址栏里输入一个地址，比如http://localhost/user/1,这个URL是会向后端发起一个get请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个404了！这也就是很多朋友在生产模式遇到404页面的原因。

那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为vue-cli在开发模式下帮你启动的那个express开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过vue-cli都帮你配置好了，所以你就不用手动配置了。

那么该如何配置呢？其实在生产模式下配置也很简单，参考vue-router给出的配置例子。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则——把构建好的那个index.html返回给前端。这样就解决了后端路由抛出的404的问题了，因为只要你输入了http://localhost/user/1这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器index.html。

浏览器拿到这个html之后，router库就开始工作，开始获取地址栏的URL信息，然后再告诉前端库（比如Vue）渲染对应的页面。到这一步就跟hash模式是类似的了。

当然，由于后端无法抛出404的页面错误，404的URL规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么URL都不匹配的404页面应该显示什么。

## 前端路由与服务器渲染

虽然前端渲染有诸多好处，不过SEO的问题，还是比较突出的。所以react、vue等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode等等概念，它们的服务端渲染对服务器的性能要求比php等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成SSR的时候也遇到了对应的性能问题，就是这个原因。

当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的html文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了SEO和服务器的性能要求。不过它无法做到全站SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。

关于预渲染，可以考虑使用prerender-spa-plugin这个webapck的插件，它的3.x版本开始使用puppeteer来构建html文件了。

## 前后端分离

得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。

前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于api的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的web开发年代。

# 事务

参考文件：https://www.jianshu.com/p/aa35c8703d61

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。  

+ ACID

    事务具有4个基本特征，分别是：
    + 原子性（Atomicity）
    + 一致性（Consistency）
    + 隔离性（Isolation）
    + 持久性（Duration）

+ 隔离级别

    ACID这4个特征中，最难理解的是隔离性。在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。4个隔离级别分别是：
    + 读未提及（READ_UNCOMMITTED）
    + 读已提交（READ_COMMITTED）
    + 可重复读（REPEATABLE_READ）
    + 顺序读（SERIALIZABLE）。



+ 事务并发引起的问题

    数据库在不同的隔离性级别下并发访问可能会出现以下几种问题：
    + 脏读（Dirty Read）
    + 不可重复读（Unrepeatable Read）
    + 幻读（Phantom Read）。

+ 事务的思维导图

![事务](img/web/transaction.png)

## ACID
+ 原子性（Atomicity）

    原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中只允许出现两种状态：
    + 全部执行成功
    + 全部执行失败  
    
    任何一项操作都会导致整个事务的失败，同时其他已经被执行的操作都被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成

+ 一致性（Consistency）
    一致性是指事务的执行不会破坏数据库数据的完整性和一致行，一个事务在执行之前和执行之后，数据库都必须处与一致性状态

    比如：A转账给B，不可能A账户扣钱，B账户没有加钱

+ 隔离性（Isolation）

    隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能被其他事务干扰，也就是说，在不同的事务并发操作相同数据时，每个事务都有各自完整的数据空间。

    一个事务内部的操作及使用的数据对其他并发事务的隔离的，并发执行的各个事务是不能相互干扰的

+ 持久性（Duration）
    事务的持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统突然崩溃或者服务器宕机等故障。只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态

## 事务并发引起的问题

+ 脏读

    一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务；而以此同时，允许另一个事务也能够访问该数据。

    脏读示例：  
    在事务A和事务B同时执行时可能会出现如下场景：

    时间|事务A（存款）|事务B（取款）
    -|-|-
    T1|开始事务|——
    T2|——|开始事务
    T3|——|查询余额（1000元）
    T4|——|取出1000元（余额0元）
    T5|查询余额（0元）|——
    T6|——|撤销事务（余额恢复1000元）
    T7|存入500元（余额500元|——
    T8|提交事务|——

+ 不可重复读

    多次读取可能会获得不同的数据

    不可重复度示例：

    时间|事务A（存款）|事务B（取款）
    -|-|-
    T1|开始事务|——
    T2|——|开始事务
    T3|——|查询余额（1000元）
    T4|查询余额（1000元）|——
    T5|——|取出1000元（余额0元）
    T6|——|提交事务
    T7|查询余额（0元）|——
    T8|提交事务|——

    事务A只进行了2次查询，结果钱从1000变成了0

+ 幻读

    指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。

    幻读示例：

    时间|事务A（统计总存款）|事务B（存款）
    -|-|-
    T1|开始事务|——
    T2|——|开始事务
    T3|统计总存款（1000元）|——
    T4|——|存入100元
    T5|——|提交事务
    T6|提交总存款（10100）|——
    T7|提交事务|——

    在一个事务中多次统计总存款时看到结果不一样。

## 事务隔离级别

+ 读未提交（READ_UNCOMMITTED）

    该隔离级别允许脏读取，隔离级别最低。

+ 读已提交（READ_COMMITTED）

    指不同执行的时候只能获取到已经提交的数据。  
    不会出现脏读，但解决不了可重复读问题

+ 可重复读（REPEATABLE_READ）

    可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别进制了不可重复读取和脏读，但是有可能出现幻读的数据。

+ 顺序读（SERIALIZABLE）

    顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。

**事务隔离级别对比**

事务隔离级别|脏读|不可重复读|幻读
-|:-:|:-:|:-:
读未提及（READ_UNCOMMITTED）|允许|允许|允许
读已提交（READ_COMMITTED）|禁止|允许|允许
可重复读（REPEATABLE_READ）|禁止|禁止|允许
顺序读（SERIALIZABLE）|禁止|禁止|禁止

4种事务隔离级别从上往下，级别越高，并发性越差，安全性就越来越高。
一般数据默认级别是读以提交或可重复读。

# 依赖注入和控制反转
依赖注入和控制反转是为了解决对象间耦合度过高的问题

+ 控制反转是一种思想  
+ 依赖注入是一种实现控制反转的设计模式

参考文档：https://www.jianshu.com/p/07af9dbbbc4b

## 控制反转
在讨论控制反转之前，我们先来看看软件系统中耦合的对象。

![web0](img/web/web0.png)

从图中可以看到，软件中的对象就像齿轮一样，协同工作，但是互相耦合，一个零件不能正常工作，整个系统就崩溃了。这是一个强耦合的系统。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。

为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC(控制反转)理论，用来实现对象之间的“解耦”。

控制反转（Inversion of Control）是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。

![web1](img/web/web1.png)

由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心。

控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：

+ 软件系统在没有引入IOC容器之前，对象A依赖于对象B，无论是创建还是使用对象B，控制权都在A自己手上。

+ 软件系统在引入IOC容器之后，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。

通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。

## 依赖注入

依赖注入就是将实例变量传入到一个对象中去。

+ 什么是依赖

    如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。
    ```
    public class Human {
        ...
        Father father;
        ...
        public Human() {
            father = new Father();
        }
    }
    ```
    这段代码存在一些问题:

    1. 如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码。
    2. 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中。
    3. 如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。

+ 依赖注入

    上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：
    ```
    public class Human {
        ...
        Father father;
        ...
        public Human(Father father) {
            this.father = father;
        }
    }
    ```
    上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。
    
    像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。

## 依赖注入和控制反转总结

1. 控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。

2. 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。

3. 通过IoC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。

# DDD领域驱动设计
参考文档：https://www.cnblogs.com/netfocus/p/5548025.html

## 什么是DDD？
DDD的全称为Domain-driven Design，即领域驱动设计。下面从领域、问题域、领域模型、设计、驱动这几个词语的含义和联系的角度去阐述DDD是如何融入到我们平时的软件开发初期阶段的。要理解什么是领域驱动设计，首先要理解什么是领域，什么是设计，还有驱动是什么意思，什么驱动什么。
+ 什么是领域？

    任何一个系统都会属于某个特定的领域，比如论坛是一个领域，只要你想做一个论坛，那这个论坛的核心业务是确定的，比如都有用户发帖、回帖等核心基本功能。比如电商平台、普通电商系统，这种都属于网上电商领域，只要是这个领域的系统，那都有商品浏览、购物车、下单、减库存、付款交易等核心环节。所以，同一个领域的系统都具有相同的核心业务，因为他们要解决的问题的本质是类似的。

    因此，我们可以推断出，一个领域本质上可以理解为就是一个问题域，只要是同一个领域，那问题域就相同。所以，只要我们确定了系统所属的领域，那这个系统的核心业务，即要解决的关键问题、问题的范围边界就基本确定了。通常我们说，要成为一个领域的专家，必须要在这个领域深入研究很多年才行。因为只有你研究了很多年，你才会遇到非常多的该领域的问题，同时你解决这个领域中的问题的经验也非常丰富。

+ 什么是设计？

    DDD中的设计主要指领域模型的设计。DDD是一种基于模型驱动开发的软件开发思想，强调领域模型是整个系统的核心，领域模型也是整个系统的核心价值所在。每一个领域，都有一个对应的领域模型，领域模型能够很好的帮我们解决复杂的业务问题。

    从领域和代码实现的角度来理解，领域模型绑定了领域和代码实现，确保了最终的代码实现就一定是解决了领域中的核心问题的。因为：
    1. 领域驱动领域模型设计；
    2. 领域模型驱动代码实现。
    
    只要保证领域模型的设计是正确的，就能确定领域模型可以解决领域中的核心问题；同理，我们只要保证代码实现是严格按照领域模型的意图来落地的，那就能保证最后出来的代码能够解决领域的核心问题的。这个思路，和传统的分析、设计、编码这几个阶段被割裂（并且每个阶段的产物也不同）的软件开发方法学形成鲜明的对比。

+ 什么是驱动？

    上面其实已经提到了，就是：
    1. 领域驱动领域模型设计。
    2. 领域模型驱动代码实现。

    DDD中，我们总是以领域为边界，分析领域中的核心问题（核心关注点），然后设计对应的领域模型，再通过领域模型驱动代码实现。当我们要开发一个系统时，应该尽量先把领域模型想清楚，然后再开始动手编码，这样的系统后期才会很好维护。

概念总结：
1. 领域就是问题域，有边界，领域中有很多问题；
2. 任何一个系统要解决的那个大问题都对应一个领域；
3. 通过建立领域模型来解决领域中的核心问题，模型驱动的思想；
4. 领域建模的目标针对我们在领域中所关心的问题，即只针对核心关注点，而不是整个领域中的所有问题；
5. 领域模型在设计时应考虑一定的抽象性、通用性，以及复用价值；
6. 通过领域模型驱动代码的实现，确保代码让领域模型落地，代码最终能解决问题；
7. 领域模型是系统的核心，是领域内的业务的直接沉淀，具有非常大的业务价值；
8. 技术架构设计或数据存储等是在领域模型的外围，帮助领域模型进行落地；

## 理解领域，拆分领域，细化领域
+ 理解领域知识是基础

    上面我们通过第一步，虽然我们明确了要做一个什么样的系统，该系统主要解决什么问题，但是就这样我们还无法开始进行实际的需求分析和模型设计，我们还必须将我们的问题进行拆分，需求进行细化。有些时候，需求方，即提出问题的人，很可能自己不清楚具体想要什么。他只知道一个概念，一个大的目标。比如他只知道要做一个股票交易系统，一个灰度发布系统，一个电商平台，一个开发工具，等。但是他不清楚这些系统应该具体做成什么样子。这个时候，我认为领域专家就非常重要了，DDD也非常强调领域专家的重要性。因为领域专家对这个领域非常了解，对领域内的各种业务场景和各种业务规则也非常清楚，总之，对这个领域内的一切业务相关的知识都非常了解。所以，他们自然就有能力表达出系统该做成什么样子。所以，要知道一个系统到底该做成什么样子，到底哪些是核心业务关注点，只能靠沉淀领域内的各种知识，别无他法。如果你不了解，就算你领域建模的能力再强，各种技术架构能力再强也是使不上力。领域专家不是某个固定的角色，而是某一类人，这类人对这个领域非常了解。比如，一个开发人员也可以是一个领域专家。假设你在一个公司开发和维护一个系统已经好几年了，但是这个系统的产品经理（PD）可能已经换过好几任了，这种情况下，这几任产品经理不一定比你更熟悉这个领域。

+ 拆分领域

    领域建模的基础是要先理解领域，让自己成为领域专家。如果做到了这点，我们就打好了坚实的基础了。但是，有时一个领域往往太复杂，涉及到的领域概念、业务规则、交互流程太多，导致我们没办法直接针对这个大的领域进行领域建模。所以，我们需要将领域进行拆分，本质上就是把大问题拆分为小问题，然后各个击破的思路。然后既然把一个大的领域划分为了多个小的领域（子域），那最关键的就是要理清每个子域的边界；然后要搞清楚哪些子域是核心子域，哪些是非核心子域，哪些是公共支撑子域；然后，还要思考子域之间的联系是什么。

    有一种看法是从业务相关性的角度去思考，也就是我们平时说的按业务功能为出发点进行划分。还是拿经典的电商系统来分析，通常一个电商系统都会包含好几个大块，比如：

        会员中心：负责用户账号登录、用户信息的管理；
        商品中心：负责商品的展示、导航、维护；
        订单中心：负责订单的生成和生命周期管理；
        交易中心：负责交易相关的业务；
        库存中心：负责维护商品的库存；
        促销中心：负责各种促销活动的支持；

    上面这些中心看起来很自然，因为大家对电子商务的这个领域都已经非常熟悉了，所以都没什么疑问，好像很自然的样子。如果我们遇到一个冷门的领域，就没办法这么容易的去划分子域了。这就需要我们先去努力理解领域内的知识。

+ 细化领域

    通过上面的两步，我们了解了领域里的知识，也对领域进行了子域划分。但这样还不够，凭这些我们还无法进行后续的领域模型设计。我们还必须再进一步细化每个子域，进一步明确每个子域的核心关注点，即需求细化。有人认为需要细化的方面有以下几点：
    
    1. 梳理领域概念：梳理出领域内我们关注的概念、概念的关系，并统一交流词汇，形成统一语言；
    2. 梳理业务规则：梳理出领域内我们关注的各种业务规则，DDD中叫不变性（invariants），比如唯一性规则，余额不能小于零等；
    3. 梳理业务场景：梳理出领域内的核心业务场景，比如电商平台中的加入购物车、提交订单、发起付款等核心业务场景；
    4. 梳理业务流程：梳理出领域内的关键业务流程，比如订单处理流程，退款流程等；

    我们从领域概念、业务规则、交互场景、业务流程等维度梳理了我们到底要什么，整理了整个系统应该具备的功能。这个工作是一个非常具有创造性和有难度的工作。我们一方面会主观的定义我们想要什么；另一方面，我们还会思考我们要的东西的合理性。把产品充分设计好，需要从各个方面去考虑，如何设计一个产品，才能更好的解决用户的核心诉求，即领域内的核心问题。如果对领域不够了解，如果想不清楚用户到底要什么，如果思考问题不够全面，又如何设计出一个合理的产品呢？

## 领域模型设计

DDD原著中提出了很多实用的建模工具：聚合、实体、值对象、工厂、仓储、领域服务、领域事件。我们可以使用这些工具，来设计每一个子域的领域模型。最终通过领域模型图将设计沉淀下来。要使用这些工具，首先就要理解每个工具的含义和使用场景。关于这些建模工具的概念和如何运用我们以后再说。




